import warnings

import numpy as np
import astropy.constants as const
import astropy.units as u
from astropy.table import QTable
from scipy.integrate import solve_ivp


problem = 'b68'


class Polytrope:
    def __init__(self, k, gamma):
        self.k = k
        self.gamma = gamma

    def __call__(self, rho_c, r, condition=None):
        self._rho_c = rho_c
        self._r_unit = r.unit
        self._condition = condition
        # It is easier to integrate with variables of the same order
        # of magnitude, so work relative to rho_c and an estimate
        # of the total mass (not critical to have it exactly right).
        self._mr_scale = (self._rho_c * (r.max() / 2) ** 3).to(u.Msun)
        # scipy integration routine cannot handle Quantity, so use
        # scaled values and multiply with scales as needed in .structure_eqs().
        sol = solve_ivp(
            self.structure_eqs,  # Function that calculates derivatives.
            t_span=r[[0, -1]].value,  # Range within which to integrate.
            y0=[0, 1],  # Initial values: Mr=0, rho/rho_c=1.
            t_eval=r.value,  # Evaluate at chosen points.
            events=self.terminate,  # Terminate when ρ<0 (or condition < 0).
        )
        if not sol.success:
            warnings.warn('Solver did not succeed.')
        # Put physical scales back on.
        r_sol = sol.t * self._r_unit
        mr = sol.y[0] * self._mr_scale
        rho = sol.y[1] * self._rho_c
        result = QTable([r_sol, mr, rho], names=['r', 'mr', 'rho'])
        if len(sol.t_events[0]):
            # If density got to 0, add a final row for that.
            assert len(sol.t_events) == 1 and len(sol.t_events[0]) == 1
            result.insert_row(len(result),
                              dict(r=sol.t_events[0][0] * self._r_unit,
                                   mr=sol.y_events[0][0, 0] * self._mr_scale,
                                   rho=sol.y_events[0][0, 1] * self._rho_c))
        # Add column with implied pressure (from polytropic EoS).
        result['p'] = (self.k * result['rho']**self.gamma).to(u.Pa)
        return result

    def structure_eqs(self, r, par):
        """Mass conservation and hydrostatic equilibrium.

        dMᵣ/dr = 4πr²ρ
        dP/dr = -GMᵣρ/r²

        Latter transformed to dρ/dr by getting dP/dρ from EoS.
        """
        if r == 0 or par[1] <= 0:
            return [0, 0]
        # Multiply with physical scale/unit.
        r = r * self._r_unit
        mr = par[0] * self._mr_scale
        rho = par[1] * self._rho_c
        # Mass conservation.
        dmr_dr = 4 * np.pi * r**2 * rho
        # Hydrostatic equibrium, use in terms of density.
        dp_dr = -const.G * mr / r**2 * rho
        # For polytropic equation of state, dP/dρ=γKρˠ⁻¹.
        dp_drho = self.k * rho ** (self.gamma - 1.) * self.gamma
        drho_dr = dp_dr / dp_drho
        # Bring back to correct unit and return just the values.
        return [(dmr_dr / self._mr_scale).to_value(1 / self._r_unit),
                (drho_dr / self._rho_c).to_value(1 / self._r_unit)]

    def terminate(self, r, par):
        if self._condition is None:
            # By default, just terminate if the density becomes less than 0.
            return par[1]

        condition = self._condition(r, mr=par[0]*self._mr_scale, rho=par[1]*self._rho_c)
        # Cannot pass back units, so get the number for any quantity output.
        return getattr(condition, 'value', condition)

    terminate.terminal = True  # If this occurs, stop integration.


if __name__ == '__main__':
    if problem == 'b68':
        # Isothermal EOS
        t = 16 * u.K
        mu = 1/(0.7 / 2 + 0.3 / 4)  # 70% molecular hydrogen, 30% Helium+heavier
        rho_c = (2e5/u.cm**3 * mu * const.m_p).si
        pc = rho_c/(mu*const.m_p) * const.k_B * t
        gamma = 1
        k = pc / rho_c ** gamma
        poly = Polytrope(k=k, gamma=gamma)
        print(f"Maximum stable size = {6.5*np.sqrt(k/(4*np.pi*const.G*rho_c)).to(u.AU)}")
        # Need to cut off solution at some external pressure.
        # From paper:
        p_ism = 2.5e-12 * u.Pa  #((0.1 / u.cm**3) * const.k_B * 1e4 * u.K).to(u.Pa)
        def p_gt_p_ism(r, mr, rho):
            return poly.k*rho**poly.gamma - p_ism

        result = poly(rho_c, np.linspace(0, 20000, 201) << u.AU, condition=p_gt_p_ism)
        print(f"Matching pressure {p_ism}")
        print(f"Match {p_ism:8.2e} at r={result[-1]['r']:8.2e}, mass {result[-1]['mr']:.2f}")
        print(f"Paper {6.9*np.sqrt(k/(4*np.pi*const.G*rho_c)).to(u.AU)}, 2.1 M⊙")
        for n_c in np.geomspace(.5e5, 8e5, 9) / u.cm**3:
            d_c = n_c * mu * const.m_p
            res = poly(d_c, np.linspace(0, 20000, 201) << u.AU,
                       condition=p_gt_p_ism)
            print(f"For n_c={n_c}, ρc={d_c:8.2e}, match p_ism at "
                  f"r={res[-1]['r']:.5g}, mr={res[-1]['mr']:8.2e}")
        mass = 2.1 * u.Msun
    elif problem == 'cc':
        # Completely convective star, Fig. 3.3
        tc = 10.**6.85*u.K
        rhoc = 10.**1.9*u.g/u.cm**3
        mu = 1/(0.7/0.5 + 0.28 / (4/3) + 0.02 / 2)
        pc = rhoc/(mu*const.m_p) * const.k_B * tc
        gamma = 5/3
        k = pc/rhoc**gamma
        poly = Polytrope(k=k, gamma=gamma)
        result = poly(rhoc, np.linspace(0, 1, 101) << u.Rsun)
        mass = result['mr'][-1]
        radius = result['r'][-1]
        print(f"mass={mass.value} {mass.unit.to_string('unicode')}")
        print(f"radius={radius.value} {radius.unit.to_string('unicode')}")
        print(f"ρc/⟨ρ⟩={(rhoc/(mass/(4*np.pi/3*radius**3))).to(1)}")
